module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,           // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_dip [3][8],    // DIP switches on IO Shield
    input io_button[5]
  ) {
  
  sig rst,a[16],b[16],in[16],alufn[6];                  // reset signal
  shifter shifter;
  boolean boolean;
  comparator comparator;
  adder adder;
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    

    
    .rst(rst){
      
      counter ctr (#SIZE(5), #DIV(25));  //instantiate seven segment display
      multi_seven_seg seg;
    }
  }
  
  decoder num_to_seg (#WIDTH(3));
  decoder num_to_digit (#WIDTH(2));
  
  counter slowclock(#SIZE(1), #DIV(26), .clk(clk), .rst(rst));
  fsm state(.clk(slowclock.value),.rst(rst)) = {STATE0,STATEA, STATEB,STATEOUT};

  dff inp_a[16];  // to store input of a
  dff inp_b[16];  // to store input of b
  


  
  always {

    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits

    usb_tx = usb_rx;        // echo the serial data
    
    in[7:0]=io_dip[0][7:0];
    in[15:8]=io_dip[1][7:0];
    alufn[5:0]=io_dip[2][5:0];
    
    a[15:0]=0;
    b[15:0]=0;
    alufn[5:0]=0;
    
    shifter.a[15:0]=a[15:0];
    shifter.b[15:0]=b[15:0];
    shifter.alufn[5:0]=alufn[5:0];
    boolean.a[15:0]=a[15:0];
    boolean.b[15:0]=b[15:0];
    boolean.alufn[5:0]=alufn[5:0];
    comparator.a[15:0]=a[15:0];
    comparator.b[15:0]=b[15:0];
    comparator.alufn[5:0]=alufn[5:0];
    adder.a[15:0]=a[15:0];
    adder.b[15:0]=b[15:0];
    adder.alufn[5:0]=alufn[5:0];
    seg.values = {8h0,8h0,8h0,8h0}; //initiate seven segment display
    
    case (state.q) {
      state.STATE0:
      if (io_button[0] == 1) { //UP BUTTON TO CHANGE STATE
        state.d = state.STATEA;
      }
        
      state.STATEA:
        a[15:0] = in[15:0];
        io_led[1][7:0] = io_dip[1];      //indicate using led that input is being read
        io_led[0][7:0] = io_dip[0];
        input_a.d = c{io_dip[1][7:0], io_dip[0][7:0]}; //concatenate values from io_dip to input
        if (io_button[2] == 1) {  //DOWN BUTTON TO CHANGE STATE
        state.d = state.STATEB;
      } else if (io_button[3] ==1){  //LEFT BUTTON TO RESET
          state.d = state.STATE0;
      }
        
      state.STATEB:
        b[15:0] = in[15:0];
        io_led[1][7:0] = io_dip[1];   
        io_led[0][7:0] = io_dip[0];
        input_b.d = c{io_dip[1][7:0], io_dip[0][7:0]};
        if (io_button[1] == 1) {  //after center button is pressed, alu will be processed 
        state.d = state.STATEOUT;
        } else if (io_button[3]==1){
            state.d = state.STATE0
        }

        
      state.STATEOUT:
        //code goes here
        
        state.d = state.STATE0;
    }
    }
}